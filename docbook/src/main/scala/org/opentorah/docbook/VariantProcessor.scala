package org.opentorah.docbook

import org.opentorah.build.{BuildContext, Dependency, InstallableDependency}
import org.opentorah.math.MathConfiguration
import org.opentorah.util.Files
import org.opentorah.xml.{Dom, Resolver, ScalaXml}

import java.io.File

final class VariantProcessor(
  documentName: String,
  inputFile: File,
  imagesDirectory: Option[String],
  variant: Variant,
  outputName: String,
  parameters: Parameters,
  mathConfiguration: MathConfiguration,
  epubEmbeddedFontsString: Option[String],
  xslt: Option[InstallableDependency.WithVersion[File]]
):
  private def format: Format = variant.format

  def distributionsNeeded: Set[InstallableDependency.WithVersion[_]] = xslt.toSet ++ Set(mathConfiguration.nodeDistribution)

  def process(
    context: BuildContext,
    layout: Layout,
    substitutions: Map[String, String]
  ): Unit =
    context.lifecycle(s"DocBook: processing '$documentName' to $outputName.")

    val tmp: File = Files.file(layout.documentTmp(documentName), outputName)
    if format.usesIntermediate then tmp.mkdirs
    val out: File = Files.file(layout.out, documentName, outputName)
    out.mkdirs

    def output(isTmp: Boolean): File = if !isTmp then out else File(tmp, Layout.outDirectory)
    def outputFile(isTmp: Boolean): File = File(
      output(isTmp),
      format.rootFilename(documentName) + "." + (if isTmp then format.intermediateFileExtension else format.outputFileExtension)
    )

    def getResolver(xsltConfiguration: Option[(Xslt, File)]): Resolver = DocBookProcessor.getResolver(
      layout,
      context,
      documentName,
      tmp,
      xsltConfiguration
    )

    val processOutputDirectory: File = output(isTmp = format.usesIntermediate)
    val processOutputFile: File = outputFile(isTmp = format.usesIntermediate)
    val finalOutputFile: File = outputFile(isTmp = false)

    format match
      case xsltFormat: XsltFormat =>
        val xslt: InstallableDependency.WithVersion[File] = this.xslt.get
        val xsltInstallation: File = xslt.getInstallation(context, installIfDoesNotExist = false, mustExist = true)

        def customStylesheetSrcOrTmp(name: String): Seq[File] =
          val srcFile: File = layout.customStylesheetSrc(name)
          val tmpFile: File = layout.customStylesheetTmp(name)
          if srcFile.exists || !tmpFile.exists then Seq(srcFile) else Seq(srcFile, tmpFile)

        val customStylesheets: Seq[File] =
          xsltFormat.common.map(_.fullName).flatMap(customStylesheetSrcOrTmp) ++
            customStylesheetSrcOrTmp(xsltFormat.name) ++
            (if variant.isDefault then Seq.empty else Seq(layout.customStylesheetSrc(variant.name)))

        xsltFormat.process(
          layout,
          context,
          documentName,
          substitutions,
          getResolver(Some((xslt.dependency.asInstanceOf[Xslt], xsltInstallation))),
          imagesDirectory,
          inputFile,
          tmp,
          processOutputDirectory,
          processOutputFile,
          finalOutputFile,
          variant.name,
          parameters,
          mathConfiguration,
          epubEmbeddedFontsString,
          xslt.dependency.asInstanceOf[Xslt],
          customStylesheets
        )

    if format.usesIntermediate then
      context.lifecycle(s"DocBook: post-processing '$documentName' to $outputName.")
      format.postProcess(
        inputDirectory = processOutputDirectory,
        outputFile = finalOutputFile
      )

object VariantProcessor:
  val doNotEdit: ScalaXml.Node = <!-- DO NOT EDIT! Generated by the DocBook plugin. -->

package org.opentorah.docbook

import org.opentorah.html.SiteHtml
import org.opentorah.math.MathConfiguration
import org.opentorah.util.{BuildContext, Distribution, Files}
import org.opentorah.xml.{Dom, Resolver, ScalaXml}
import java.io.File

final class VariantProcessor(
  documentName: String,
  inputFile: File,
  imagesDirectory: Option[String],
  variant: Variant,
  outputName: String,
  parameters: Parameters,
  mathConfiguration: MathConfiguration,
  epubEmbeddedFontsString: Option[String],
  xslt: Option[Xslt]
):
  private def format: Format = variant.format

  def distributionsNeeded: Set[Distribution[_]] = xslt.toSet ++ mathConfiguration.distributionsNeeded

  def process(
    context: BuildContext,
    layout: Layout,
    siteHtml: SiteHtml,
    substitutions: Map[String, String]
  ): Unit =
    context.lifecycle(s"DocBook: processing '$documentName' to $outputName.")

    val tmp: File = Files.file(layout.documentTmp(documentName), outputName)
    if format.usesIntermediate then tmp.mkdirs
    val out: File = Files.file(layout.out, documentName, outputName)
    out.mkdirs

    def output(isTmp: Boolean): File = if !isTmp then out else File(tmp, Layout.outDirectory)
    def outputFile(isTmp: Boolean): File = File(
      output(isTmp),
      format.rootFilename(documentName) + "." + (if isTmp then format.intermediateFileExtension else format.outputFileExtension)
    )

    def getResolver(xsltConfiguration: Option[(Xslt, File)]): Resolver = DocBookProcessor.getResolver(
      layout,
      context,
      documentName,
      tmp,
      xsltConfiguration
    )

    val processOutputDirectory: File = output(isTmp = format.usesIntermediate)
    val processOutputFile: File = outputFile(isTmp = format.usesIntermediate)
    val finalOutputFile: File = outputFile(isTmp = false)

    format match
      case xsltFormat: XsltFormat =>
        val xslt: Xslt = this.xslt.get
        val xsltInstallation: File = xslt.getInstallation(context).get

        def customStylesheetSrcOrTmp(name: String): Seq[File] =
          val srcFile: File = layout.customStylesheetSrc(name)
          val tmpFile: File = layout.customStylesheetTmp(name)
          if srcFile.exists || !tmpFile.exists then Seq(srcFile) else Seq(srcFile, tmpFile)

        val customStylesheets: Seq[File] =
          xsltFormat.common.map(_.fullName).flatMap(customStylesheetSrcOrTmp) ++
            customStylesheetSrcOrTmp(xsltFormat.name) ++
            (if variant.isDefault then Seq.empty else Seq(layout.customStylesheetSrc(variant.name)))

        xsltFormat.process(
          layout,
          context,
          documentName,
          substitutions,
          getResolver(Some((xslt, xsltInstallation))),
          imagesDirectory,
          inputFile,
          tmp,
          processOutputDirectory,
          processOutputFile,
          finalOutputFile,
          variant.name,
          parameters,
          mathConfiguration,
          epubEmbeddedFontsString,
          xslt,
          customStylesheets
        )

      case directFormat: DirectFormat =>
        // TODO Scala XML does not work with XInclude-aware parsers
        // (see https://github.com/scala/scala-xml/issues/506),
        // but DocBook uses XInclude to assemble the document,
        // so I parse to Dom, pretty-print combined document to String and re-parse it with ScalaXml:
        val dom: Dom.Element = Dom.loadFromUrl(
          Files.file2url(inputFile),
          resolver = Some(getResolver(None))
        )
        val xml: ScalaXml.Element = ScalaXml.loadFromString(DocBook.prettyPrinter.renderWithHeader(Dom)(dom))

        directFormat.process(
          xml,
          parameters,
          mathConfiguration,
          siteHtml,
          processOutputFile
        )

    if format.usesIntermediate then
      context.lifecycle(s"DocBook: post-processing '$documentName' to $outputName.")
      format.postProcess(
        inputDirectory = processOutputDirectory,
        outputFile = finalOutputFile
      )

object VariantProcessor:
  val doNotEdit: ScalaXml.Node = <!-- DO NOT EDIT! Generated by the DocBook plugin. -->

package org.opentorah.docbook

import org.opentorah.html.SiteHtml
import org.opentorah.math.MathConfiguration
import org.opentorah.util.{BuildContext, Distribution, Files}
import org.opentorah.xml.{Catalog, Resolver, ScalaXml}
import java.io.File

final class VariantProcessor(
  documentName: String,
  inputFile: File,
  imagesDirectory: Option[String],
  variant: Variant,
  outputName: String,
  parameters: Parameters,
  mathConfiguration: MathConfiguration,
  epubEmbeddedFontsString: Option[String],
  xslt: Option[Xslt]
):
  private def format: Format = variant.format

  def distributionsNeeded: Set[Distribution[_]] = xslt.toSet ++ mathConfiguration.distributionsNeeded

  def process(
    context: BuildContext,
    layout: Layout,
    siteHtml: SiteHtml,
    substitutions: Map[String, String],
    documentTmp: File,
    dtdFile: Option[File],
    dataDirectory: Option[File]
  ): Unit =
    context.lifecycle(s"DocBook: processing '$documentName' to $outputName.")

    val tmp: File = Files.file(documentTmp, outputName)
    if format.usesIntermediate then tmp.mkdirs
    val out: File = Files.file(layout.out, documentName, outputName)
    out.mkdirs

    val catalog: File = Files.file(tmp, Layout.catalogDirectory, "catalog.xml")
    def resolver: Resolver = Resolver(catalog, context.getLogger)

    def writeCatalog(xsltConfiguration: Option[(Xslt, File)]): Unit = Catalog.prettyPrinter.write(
      file = catalog,
      doctype = Some(Catalog),
      element = Catalog.catalog(VariantProcessor.catalogContent(
        xsltConfiguration,
        layout.customCatalog,
        dtdFile,
        dataDirectory
      ))
    )

    def output(isTmp: Boolean): File = if !isTmp then out else File(tmp, Layout.outDirectory)
    def outputFile(isTmp: Boolean): File = File(
      output(isTmp),
      format.rootFilename(documentName) + "." + (if isTmp then format.intermediateFileExtension else format.outputFileExtension)
    )
    val processOutputDirectory: File = output(isTmp = format.usesIntermediate)
    val processOutputFile: File = outputFile(isTmp = format.usesIntermediate)
    val finalOutputFile: File = outputFile(isTmp = false)

    format match
      case xsltFormat: XsltFormat =>
        val xslt: Xslt = this.xslt.get
        val xsltInstallation: File = xslt.getInstallation(context).get

        writeCatalog(Some((xslt, xsltInstallation)))

        def customStylesheetSrcOrTmp(name: String): Seq[File] =
          val srcFile: File = layout.customStylesheetSrc(name)
          val tmpFile: File = layout.customStylesheetTmp(name)
          if srcFile.exists || !tmpFile.exists then Seq(srcFile) else Seq(srcFile, tmpFile)

        val customStylesheets: Seq[File] =
          xsltFormat.common.map(_.fullName).flatMap(customStylesheetSrcOrTmp) ++
            customStylesheetSrcOrTmp(xsltFormat.name) ++
            (if variant.isDefault then Seq.empty else Seq(layout.customStylesheetSrc(variant.name)))

        xsltFormat.process(
          layout,
          context,
          documentName,
          substitutions,
          resolver,
          imagesDirectory,
          inputFile,
          tmp,
          processOutputDirectory,
          processOutputFile,
          finalOutputFile,
          variant.name,
          parameters,
          mathConfiguration,
          epubEmbeddedFontsString,
          xslt,
          customStylesheets
        )

      case directFormat: DirectFormat =>
        writeCatalog(None)

        directFormat.process(
          resolver,
          inputFile,
          parameters,
          mathConfiguration,
          siteHtml,
          processOutputFile
        )

    if format.usesIntermediate then
      context.lifecycle(s"DocBook: post-processing '$documentName' to $outputName.")
      format.postProcess(
        inputDirectory = processOutputDirectory,
        outputFile = finalOutputFile
      )

object VariantProcessor:
  val doNotEdit: ScalaXml.Node = <!-- DO NOT EDIT! Generated by the DocBook plugin. -->

  private def catalogContent(
    xsltConfiguration: Option[(Xslt, File)],
    customCatalog: File,
    dtdFile: Option[File],
    dataDirectory: Option[File]
  ): ScalaXml.Nodes =
    Seq(
      VariantProcessor.doNotEdit,
      ScalaXml.mkComment(s"customizations go into $customCatalog.")
    ) ++
    (if customCatalog.exists
     then Seq(Catalog.nextCatalog(customCatalog.getPath))
     else Seq(
      <!-- ... and had it existed, it'd be the next catalog here instead of the system one: -->,
      Catalog.nextCatalogSystem
     )
    ) ++
    (if dtdFile.isEmpty then Seq.empty else Seq(
    <!-- substitutions DTD -->,
      Catalog.public(publicId = DocBook.dtdId, uri = Files.file2url(dtdFile.get).toString)
    )) ++
    (if dataDirectory.isEmpty then Seq.empty else
      val rewritePrefix: String = Files.file2url(dataDirectory.get).toString
        Seq(<!-- generated data -->) ++
        (for dataSystemId <- Seq(
          "data:",
          "data:/",
          "urn:docbook:data:/",
          "urn:docbook:data:",
          "urn:docbook:data/",
          "http://opentorah.org/docbook/data/"
        ) yield Catalog.rewriteSystem(
          rewritePrefix = rewritePrefix,
          systemIdStartString = dataSystemId
        ))
    ) ++ xsltConfiguration.fold(Seq.empty)((xslt: Xslt, xsltDirectory: File) => Seq(
      ScalaXml.mkComment(s"DocBook ${xslt.name} stylesheets"),
      Catalog.rewriteUri(rewritePrefix = s"$xsltDirectory/", uriStartString = s"${xslt.uri}/")
    ))
